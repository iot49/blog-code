#!/usr/bin/env bash
set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$REPO_ROOT"

pass() { echo -e "${GREEN}✓${RESET} $1"; }
fail() { echo -e "${RED}✗${RESET} $1"; }
info() { echo -e "${CYAN}▶${RESET} $1"; }
warn() { echo -e "${YELLOW}⚠${RESET} $1"; }

echo -e "\n${BOLD}=== Blog Test Suite ===${RESET}\n"

ERRORS=0

# ── 1. Prettier ───────────────────────────────────────────────────────────────
info "Prettier..."
if npm run check:prettier --silent 2>&1 >/dev/null; then
  pass "Prettier"
else
  fail "Prettier failed (try: npm run fix:prettier)"
  ERRORS=$((ERRORS + 1))
fi

# ── 2. ESLint ─────────────────────────────────────────────────────────────────
info "ESLint..."
if npm run check:eslint --silent 2>&1 >/dev/null; then
  pass "ESLint"
else
  fail "ESLint failed (try: npm run fix:eslint)"
  ERRORS=$((ERRORS + 1))
fi

# ── 3. Astro Type Check ───────────────────────────────────────────────────────
info "Astro type check..."
if npm run check:astro --silent 2>&1 >/dev/null; then
  pass "Astro type check"
else
  fail "Astro type check failed"
  ERRORS=$((ERRORS + 1))
fi

# ── 4. Content Structure Check ────────────────────────────────────────────────
info "Content structure check..."
if [[ -d "../blog-content" ]]; then
  pass "Content repo found at ../blog-content"
  # Sync posts for testing
  rsync -av --update --delete "../blog-content/src/data/post/" src/data/post/ >/dev/null
else
  warn "Content repo NOT found at ../blog-content (will use local samples)"
fi

# ── 5. Build ──────────────────────────────────────────────────────────────────
info "Production build..."
# Clean dist first to ensure we test a fresh build
rm -rf dist
# Set dummy Giscus env vars for testing the widget presence
export PUBLIC_GISCUS_REPO="iot49/blog-comments"
export PUBLIC_GISCUS_REPO_ID="dummy"
export PUBLIC_GISCUS_CATEGORY="General"
export PUBLIC_GISCUS_CATEGORY_ID="dummy"

if npm run build --silent 2>&1 >/dev/null; then
  if [[ -d dist && "$(ls -A dist)" ]]; then
    pass "Build succeeded"
  else
    fail "Build command succeeded but dist/ is empty or missing"
    ERRORS=$((ERRORS + 1))
  fi
else
  fail "Build failed"
  ERRORS=$((ERRORS + 1))
fi

# 6. Access-Level Security Checks ───────────────────────────────────────────
info "Verifying access-level routing..."
# We now allow 'accessLevel: friends' etc. to appear in the metadata for search index,
# but we must NOT have any actual post content files for these levels in dist/public/
# We check if restricted post metadata appears in its own right (not as part of a JSON index)
if [[ -d "dist/public" ]]; then
  # Grep for accessLevel property that is NOT part of a data-search attribute
  # This is a bit tricky with grep, so we'll check for files that shouldn't be here.
  RESTRICTED_FOLDERS=("friends" "family" "private")
  FOUND_RESTRICTED=0
  for folder in "${RESTRICTED_FOLDERS[@]}"; do
    if [[ -d "dist/public/${folder}" ]]; then
        fail "Restricted folder 'dist/public/${folder}' should NOT exist!"
        FOUND_RESTRICTED=1
    fi
  done

  if [[ $FOUND_RESTRICTED -eq 0 ]]; then
    pass "No restricted folders found under dist/public/"
  else
    ERRORS=$((ERRORS + 1))
  fi
else
  warn "dist/public/ not found (no public posts?)"
fi

# ── 7. Search Data Privacy Checks ─────────────────────────────────────────────
info "Verifying search index privacy..."
# Find the built JS or HTML file that contains the search data
SEARCH_INDEX_FILE=$(find dist -type f -name "*.html" -exec grep -l "data-search" {} + | head -n 1)

if [[ -n "$SEARCH_INDEX_FILE" ]]; then
  # 1. Verify restricted titles ARE present (Discoverability)
  if grep -q "Test Friends Post" "$SEARCH_INDEX_FILE"; then
    pass "Restricted post titles allowed in search index (Discoverability)"
  else
    fail "Restricted post title 'Test Friends Post' NOT found in search index!"
    ERRORS=$((ERRORS + 1))
  fi

  # 2. Verify restricted CONTENT/EXCERPT is NOT present (Privacy)
  # 'This is a friends-only post.' is the excerpt/content for that test post.
  if grep -q "This is a friends-only post" "$SEARCH_INDEX_FILE"; then
    fail "Restricted post CONTENT found in search index!"
    ERRORS=$((ERRORS + 1))
  else
    pass "Restricted post content NOT found in search index"
  fi
else
   warn "Could not locate search index in built files"
fi

# ── 8. Draft Post Exclusion Checks ────────────────────────────────────────────
info "Verifying draft post exclusion..."
# Find all draft posts in src/data/post
DRAFT_POSTS=$(find src/data/post -type f -name "*.md*" -exec grep -l "draft: true" {} + 2>/dev/null || true)

if [[ -z "$DRAFT_POSTS" ]]; then
  warn "No draft posts found to check."
else
  DRAFT_FOUND=0
  for post in $DRAFT_POSTS; do
    # Extract slug from filename (e.g., src/data/post/test-draft.md -> test-draft)
    slug=$(basename "$post" | sed 's/\.mdx\?$//')
    
    # Check if the slug exists in dist/
    if find dist -name "${slug}" 2>/dev/null | grep -q .; then
      fail "Draft post '$slug' found in dist/!"
      DRAFT_FOUND=1
    elif find dist -name "${slug}.html" 2>/dev/null | grep -q .; then
        fail "Draft post '$slug.html' found in dist/!"
        DRAFT_FOUND=1
    fi
  done
  
  if [[ $DRAFT_FOUND -eq 0 ]]; then
    pass "All draft posts excluded from dist/"
  else
    ERRORS=$((ERRORS + 1))
  fi
fi

# ── 9. Giscus Comments Checks ─────────────────────────────────────────────────
info "Verifying Giscus widget presence..."
# Check in a sample public post
SAMPLE_POST=$(find dist/public -name "index.html" | head -n 1)
if [[ -n "$SAMPLE_POST" ]]; then
  if grep -q "giscus.app/client.js" "$SAMPLE_POST"; then
    pass "Giscus widget present in public post HTML"
  else
    fail "Giscus widget NOT found in $SAMPLE_POST!"
    ERRORS=$((ERRORS + 1))
  fi
else
  warn "No public posts found to check for Giscus widget."
fi

# ── 10. Translation element Checks ───────────────────────────────────────────
info "Verifying translation element presence..."
# Check in a sample public post
if [[ -n "$SAMPLE_POST" ]]; then
  if grep -qi "translate-button" "$SAMPLE_POST"; then
    pass "Translation element present in public post HTML"
  else
    fail "Translation element NOT found in $SAMPLE_POST!"
    ERRORS=$((ERRORS + 1))
  fi
else
  warn "No public posts found to check for translation element."
fi

# ── 11. Image Asset Pipeline Checks ───────────────────────────────────────────
info "Verifying image asset pipeline..."
# Check if there are any images in src/data/post/images (samples)
IMAGE_SAMPLES=$(find src/data/post/images -type f \( -name "*.png" -o -name "*.jpg" -o -name "*.webp" \) 2>/dev/null | wc -l)
if [[ $IMAGE_SAMPLES -gt 0 ]]; then
  # Check if any images made it to dist/_astro (optimized)
  # Astro 5 uses _astro/ directory for assets by default
  DIST_ASSETS=$(find dist/_astro -type f \( -name "*.webp" -o -name "*.png" -o -name "*.jpg" \) 2>/dev/null | wc -l)
  if [[ $DIST_ASSETS -gt 0 ]]; then
    pass "Image assets successfully processed and optimized"
  else
    fail "Images found in src/data/post/images but not in dist/_astro/!"
    ERRORS=$((ERRORS + 1))
  fi
else
  warn "No image samples found in src/data/post/images to verify pipeline."
fi

# ── 12. Cloudflare Infrastructure Checks ─────────────────────────────────────
info "Verifying Cloudflare infrastructure script..."
if [[ -f infra/cloudflare-access.sh ]]; then
  # Syntax check only
  bash -n infra/cloudflare-access.sh && pass "Cloudflare infra script syntax OK" \
    || { fail "Cloudflare infra script syntax error"; ERRORS=$((ERRORS + 1)); }
else
  fail "Cloudflare infra script 'infra/cloudflare-access.sh' is missing!"
  ERRORS=$((ERRORS + 1))
fi

# ── 13. Documentation posts Checks ──────────────────────────────────────────
info "Verifying documentation posts presence..."
# Slugs are derived from the path under src/data/post/
DOC_PATH_SLUGS=("docs/overview" "docs/installation" "docs/authentication" "docs/comments" "docs/search" "docs/translation" "docs/vscode-images" "docs/deployment" "docs/jupyter-notebooks")
MISSING=0
for slug in "${DOC_PATH_SLUGS[@]}"; do
  # In dist/public/, hierarchical slugs are reflected in subdirectories
  if [[ ! -f "dist/public/${slug}/index.html" ]]; then
    warn "Doc post missing from dist: public/${slug}/index.html"
    MISSING=$((MISSING + 1))
  fi
done

if [[ $MISSING -eq 0 ]]; then
  pass "All documentation posts present in dist/public/docs/"
else
  fail "$MISSING documentation posts missing"
  ERRORS=$((ERRORS + 1))
fi

# ── Summary ───────────────────────────────────────────────────────────────────
echo ""
if [[ $ERRORS -gt 0 ]]; then
  echo -e "${RED}${BOLD}✗ $ERRORS check(s) failed.${RESET}"
  exit 1
fi

echo -e "${GREEN}${BOLD}✓ All checks passed!${RESET}\n"
exit 0
